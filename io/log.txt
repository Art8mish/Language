buf: 
type main (var zombie, var urf)
{
    var x = 2.546;
    var y =  4.45;

    if  (tg(x) - 4 + 17.3)
    {
        printf( x);
        var z = pow(6 + x, 5) + 7 - 9 / x;
    }
    else
    {
        cos(main (20 -x * 6, urf));
        scanf(&x, &y);
        x = y - 7 + 9;
    }

    return 142.33 + 5;
}

void frt(var z)
{
    var tp = cos(5);
    frt(z);

    return ;
}






























lex_structs: 
[0]: VAR_FUNC
[1]: STR: main (func_name: 1)
[2]: (
[3]: VAR
[4]: STR: zombie (func_name: 0)
[5]: ,
[6]: VAR
[7]: STR: urf (func_name: 0)
[8]: )
[9]: {
[10]: VAR
[11]: STR: x (func_name: 0)
[12]: EQ
[13]: NUM: 2.546
[14]: ;
[15]: VAR
[16]: STR: y (func_name: 0)
[17]: EQ
[18]: NUM: 4.45
[19]: ;
[20]: IF
[21]: (
[22]: OP: 8
[23]: (
[24]: STR: x (func_name: 0)
[25]: )
[26]: OP: 2
[27]: NUM: 4
[28]: OP: 1
[29]: NUM: 17.3
[30]: )
[31]: {
[32]: IN
[33]: (
[34]: STR: x (func_name: 0)
[35]: )
[36]: ;
[37]: VAR
[38]: STR: z (func_name: 0)
[39]: EQ
[40]: OP: 5
[41]: (
[42]: NUM: 6
[43]: OP: 1
[44]: STR: x (func_name: 0)
[45]: ,
[46]: NUM: 5
[47]: )
[48]: OP: 1
[49]: NUM: 7
[50]: OP: 2
[51]: NUM: 9
[52]: OP: 4
[53]: STR: x (func_name: 0)
[54]: ;
[55]: }
[56]: ELSE
[57]: {
[58]: OP: 7
[59]: (
[60]: STR: main (func_name: 0)
[61]: (
[62]: NUM: 20
[63]: OP: 2
[64]: STR: x (func_name: 0)
[65]: OP: 3
[66]: NUM: 6
[67]: ,
[68]: STR: urf (func_name: 0)
[69]: )
[70]: )
[71]: ;
[72]: OUT
[73]: (
[74]: STR: & (func_name: 0)
[75]: STR: x (func_name: 0)
[76]: ,
[77]: STR: & (func_name: 0)
[78]: STR: y (func_name: 0)
[79]: )
[80]: ;
[81]: STR: x (func_name: 0)
[82]: EQ
[83]: STR: y (func_name: 0)
[84]: OP: 2
[85]: NUM: 7
[86]: OP: 1
[87]: NUM: 9
[88]: ;
[89]: }
[90]: RET
[91]: NUM: 142.33
[92]: OP: 1
[93]: NUM: 5
[94]: ;
[95]: }
[96]: VOID_FUNC
[97]: STR: frt (func_name: 1)
[98]: (
[99]: VAR
[100]: STR: z (func_name: 0)
[101]: )
[102]: {
[103]: VAR
[104]: STR: tp (func_name: 0)
[105]: EQ
[106]: OP: 7
[107]: (
[108]: NUM: 5
[109]: )
[110]: ;
[111]: STR: frt (func_name: 0)
[112]: (
[113]: STR: z (func_name: 0)
[114]: )
[115]: ;
[116]: RET
[117]: ;
[118]: }
buf: 
type main (var zombie, var urf)
{
    var x = 2.546;
    var y =  4.45;

    if  (tg(x) - 4 + 17.3)
    {
        printf( x);
        var z = pow(6 + x, 5) + 7 - 9 / x;
    }
    else
    {
        cos(main (20 -x * 6, urf));
        scanf(&x, &y);
        x = y - 7 + 9;
    }

    return 142.33 + 5;
}

void frt(var z)
{
    var tp = cos(5);
    frt(z);

    return ;
}






























lex_structs: 
[0]: VAR_FUNC
[1]: STR: main (func_name: 1)
[2]: (
[3]: VAR
[4]: STR: zombie (func_name: 0)
[5]: ,
[6]: VAR
[7]: STR: urf (func_name: 0)
[8]: )
[9]: {
[10]: VAR
[11]: STR: x (func_name: 0)
[12]: EQ
[13]: NUM: 2.546
[14]: ;
[15]: VAR
[16]: STR: y (func_name: 0)
[17]: EQ
[18]: NUM: 4.45
[19]: ;
[20]: IF
[21]: (
[22]: OP: 8
[23]: (
[24]: STR: x (func_name: 0)
[25]: )
[26]: OP: 2
[27]: NUM: 4
[28]: OP: 1
[29]: NUM: 17.3
[30]: )
[31]: {
[32]: IN
[33]: (
[34]: STR: x (func_name: 0)
[35]: )
[36]: ;
[37]: VAR
[38]: STR: z (func_name: 0)
[39]: EQ
[40]: OP: 5
[41]: (
[42]: NUM: 6
[43]: OP: 1
[44]: STR: x (func_name: 0)
[45]: ,
[46]: NUM: 5
[47]: )
[48]: OP: 1
[49]: NUM: 7
[50]: OP: 2
[51]: NUM: 9
[52]: OP: 4
[53]: STR: x (func_name: 0)
[54]: ;
[55]: }
[56]: ELSE
[57]: {
[58]: OP: 7
[59]: (
[60]: STR: main (func_name: 0)
[61]: (
[62]: NUM: 20
[63]: OP: 2
[64]: STR: x (func_name: 0)
[65]: OP: 3
[66]: NUM: 6
[67]: ,
[68]: STR: urf (func_name: 0)
[69]: )
[70]: )
[71]: ;
[72]: OUT
[73]: (
[74]: STR: & (func_name: 0)
[75]: STR: x (func_name: 0)
[76]: ,
[77]: STR: & (func_name: 0)
[78]: STR: y (func_name: 0)
[79]: )
[80]: ;
[81]: STR: x (func_name: 0)
[82]: EQ
[83]: STR: y (func_name: 0)
[84]: OP: 2
[85]: NUM: 7
[86]: OP: 1
[87]: NUM: 9
[88]: ;
[89]: }
[90]: RET
[91]: NUM: 142.33
[92]: OP: 1
[93]: NUM: 5
[94]: ;
[95]: }
[96]: VOID_FUNC
[97]: STR: frt (func_name: 1)
[98]: (
[99]: VAR
[100]: STR: z (func_name: 0)
[101]: )
[102]: {
[103]: VAR
[104]: STR: tp (func_name: 0)
[105]: EQ
[106]: OP: 7
[107]: (
[108]: NUM: 5
[109]: )
[110]: ;
[111]: STR: frt (func_name: 0)
[112]: (
[113]: STR: z (func_name: 0)
[114]: )
[115]: ;
[116]: RET
[117]: ;
[118]: }
buf: 
type main (var zombie, var urf)
{
    var x = 2.546;
    var y =  4.45;

    if  (tg(x) - 4 + 17.3)
    {
        printf( x);
        var z = pow(6 + x, 5) + 7 - 9 / x;
    }
    else
    {
        cos(main (20 -x * 6, urf));
        scanf(&x, &y);
        x = y - 7 + 9;
    }

    return 142.33 + 5;
}

void frt(var z)
{
    var tp = cos(5);
    frt(z);

    return ;
}






























lex_structs: 
[0]: VAR_FUNC
[1]: STR: main (func_name: 1)
[2]: (
[3]: VAR
[4]: STR: zombie (func_name: 0)
[5]: ,
[6]: VAR
[7]: STR: urf (func_name: 0)
[8]: )
[9]: {
[10]: VAR
[11]: STR: x (func_name: 0)
[12]: EQ
[13]: NUM: 2.546
[14]: ;
[15]: VAR
[16]: STR: y (func_name: 0)
[17]: EQ
[18]: NUM: 4.45
[19]: ;
[20]: IF
[21]: (
[22]: OP: 8
[23]: (
[24]: STR: x (func_name: 0)
[25]: )
[26]: OP: 2
[27]: NUM: 4
[28]: OP: 1
[29]: NUM: 17.3
[30]: )
[31]: {
[32]: IN
[33]: (
[34]: STR: x (func_name: 0)
[35]: )
[36]: ;
[37]: VAR
[38]: STR: z (func_name: 0)
[39]: EQ
[40]: OP: 5
[41]: (
[42]: NUM: 6
[43]: OP: 1
[44]: STR: x (func_name: 0)
[45]: ,
[46]: NUM: 5
[47]: )
[48]: OP: 1
[49]: NUM: 7
[50]: OP: 2
[51]: NUM: 9
[52]: OP: 4
[53]: STR: x (func_name: 0)
[54]: ;
[55]: }
[56]: ELSE
[57]: {
[58]: OP: 7
[59]: (
[60]: STR: main (func_name: 0)
[61]: (
[62]: NUM: 20
[63]: OP: 2
[64]: STR: x (func_name: 0)
[65]: OP: 3
[66]: NUM: 6
[67]: ,
[68]: STR: urf (func_name: 0)
[69]: )
[70]: )
[71]: ;
[72]: OUT
[73]: (
[74]: STR: & (func_name: 0)
[75]: STR: x (func_name: 0)
[76]: ,
[77]: STR: & (func_name: 0)
[78]: STR: y (func_name: 0)
[79]: )
[80]: ;
[81]: STR: x (func_name: 0)
[82]: EQ
[83]: STR: y (func_name: 0)
[84]: OP: 2
[85]: NUM: 7
[86]: OP: 1
[87]: NUM: 9
[88]: ;
[89]: }
[90]: RET
[91]: NUM: 142.33
[92]: OP: 1
[93]: NUM: 5
[94]: ;
[95]: }
[96]: VOID_FUNC
[97]: STR: frt (func_name: 1)
[98]: (
[99]: VAR
[100]: STR: z (func_name: 0)
[101]: )
[102]: {
[103]: VAR
[104]: STR: tp (func_name: 0)
[105]: EQ
[106]: OP: 7
[107]: (
[108]: NUM: 5
[109]: )
[110]: ;
[111]: STR: frt (func_name: 0)
[112]: (
[113]: STR: z (func_name: 0)
[114]: )
[115]: ;
[116]: RET
[117]: ;
[118]: }
